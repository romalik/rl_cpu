|15|14|13|12|11|10|9|8| |7|6|5|4|3|2|1|0|
|--|--|--|--|--|--|-|-| |P|S|L|B|J|aluop|
|--|--|--|--|--|--|-|-| |1|1| |ext|xxxxx|

J - jump
L - long instruction
B - bp-relative
P - push
S - store

P=S=1 : ext mode
00 call
01 ret
10 indir


--- constb arg
push arg on stack
arg: 0-255

[arg|constb]

sp++
sp->ml
IRHigh->mw
pc++

-----


--- constw arg
push arg on stack
arg: 0-65535

[xxx|constw][arg]

sp++
pc++
pc->ml
mr->T
sp->ml
T->mw
pc++

-----

--- store
pop address, pop data, write data to address

[store]

sp->ml
mr->T
sp--
sp->ml
mr->T2
T2->ml
T->mw
pc++


--- storeconst arg
pop data, write to arg address
[storeconst][arg]





--- indir
pop address, push data on address

[indir]

sp->ml
mr->T
T->ml
mr->T
sp->ml
T->mw
pc++

--- {add|sub|and|or|xor}
perform arithmetic on two popped stack values, push result

sp->ml
mr->A
sp--
sp->ml
mr->B
alu->mw
pc++
-----

--- {add|sub|and|or|xor}constb arg
perform arithmetic on popped stack value and arg, push result
[arg8|op]

sp->ml
mr->A
IRHigh->B
alu->mw
pc++

-----


--- {add|sub|and|or|xor}constw arg
perform arithmetic on popped stack value and arg, push result
[op][arg16]
sp->ml
mr->A
pc++
pc->ml
mr->B
sp->ml
alu->mw
pc++

-----

--- jmp 
pop value, jump there

sp->ml
sp--
mr->pc


--- jmpw arg
jump to absolute [arg]

[op][arg16]

pc++
pc->ml
mr->pc


-----


--- [je|jne|jl|jle|jg|jge] arg
pop two vals, compare, jump if possible

[op][arg16]
sp->ml
sp--
mr->A
sp->ml
sp--
mr->B
pc++
pc->ml
pc++ //if not cond load
mr->pcCondLoad



--- [je|jne|jl|jle|jg|jge]constb arg
pop val, compare with short arg, jump if possible

[arg8|op][arg16]
sp->ml
sp--
mr->A
IRHigh->B
pc++
pc->ml
pc++ //if not cond load
mr->pcCondLoad




--- call

pc++    //point to next instr to return

sp->ml
mr->A   //get call addr

pc->mw  //store return address

sp++	//store current arg ptr
sp->ml
ap->mw

sp++	//store current base ptr
sp->ml
bp->mw

bp->ap //set new arg ptr

sp->bp //set new base ptr

A->pc  //jump

-push bp


--- ret

sp->ml //save retval
mr->A 

bp->sp //rewind stack
sp--

sp->ml //restore previous frame bp
mr->bp
sp--

sp->ml
mr->ap //restore previous frame ap
sp--

sp->ml //return
mr->pc

A->mw //place retval


==========

frame



.
caller arglist <----- ap
caller locals
. |
. |
. | - variable stack
. |
. |
return pc
prev ap
prev bp 
callee arglist <----- bp
local 1
local 2
local 3
.
.
.


==========
-----

aluop:
j = 0		j = 1
000 +		0		
001 -		>
010 and		==
011 or		>=
100 xor		<
101 shift	!=
110		<=
111		1

cmp output:
	C Z
>	0 0
<	1 0
=	0 1
2->4
>   0001
<   0100
=   0010

JA = sum(output (*) input)


