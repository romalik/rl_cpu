/******************************************************************************/
/*                                   ROCKEDIT                                 */
/******************************************************************************/
/*                                                                            */
/* Version : 1.3.                                                             */
/* Date    : 21-Jun-1998.                                                     */
/* Author  : Ross N. Williams (ross@rocksoft.com).                            */
/*                                                                            */
/* Legal   : Copyright (C) Ross N. Williams 1994-1998.                        */
/*           However, permission is granted to make and distribute verbatim   */
/*           or modified copies of this program on a non-commercial basis,    */
/*           provided that this header block and copyright notice are         */
/*           retained verbatim, and all modifications to the original         */
/*           release are documented in the modification log below.            */
/*                                                                            */
/* No warranty:                                                               */
/*           This program is distributed WITHOUT ANY WARRANTY; without even   */
/*           the implied warranty of MERCHANTABILITY or FITNESS FOR A         */
/*           PARTICULAR PURPOSE.                                              */
/*                                                                            */
/* Description:                                                               */
/*           This is the Rocksoft portable editor, for use on machines that   */
/*           have a C compiler, but don't have a very good (or familiar)      */
/*           text editor.                                                     */
/*                                                                            */
/* Motivation:                                                                */
/*           When porting programs to many different operating systems, a     */
/*           problem that repeatedly arises is that of having to learn many   */
/*           different text editors. This would not be such a problem if it   */
/*           it weren't for the fact that many of the built-in text editors   */
/*           in common operating systems are brain dead. After attempting to  */
/*           learn a number of different text editors on different machines,  */
/*           I decided to solve the problem once and for all by writing my    */
/*           own highly portable text editor that I could use on any machine. */
/*           For me, Rockedit is "The Last Text Editor"! :-)                  */
/*                                                                            */
/* Design goals:                                                              */
/*           * Must be EXTREMELY PORTABLE (FTP and compile on target).        */
/*             - No external preprocessors or tools (such as FunnelWeb).      */
/*             - Source must be in a single "rockedit.c" file.                */
/*             - Doesn't rely on curses or any other library (assumes VT100). */
/*           * No copyright hassles. The editor must be able to be installed  */
/*             on machines all over the planet without people worrying about  */
/*             copyright and intellectual property.                           */
/*           * Doesn't employ problem characters (e.g. escape, Control-C).    */
/*           * Must be easy to learn.                                         */
/*                                                                            */
/* Current state:                                                             */
/*           I wrote this editor during a two-day hack session to avoid       */
/*           having to use a particular editor when porting the Veracity      */
/*           data integrity product to HP/UX. While it generally works, this  */
/*           editor is NOT polished and is NOT in terrific shape. Under no    */
/*           circumstances should it be treated as typical of the quality of  */
/*           code generated by myself or Rocksoft. The sole reason that I     */
/*           released this editor unpolished is because I know that if I      */
/*           wait until I find time to clean it up properly then it probably  */
/*           won't be released for another year or so. I feel it's better to  */
/*           at least let people benefit from it now, even though it's        */
/*           imperfect.                                                       */
/*                                                                            */
/* User Manual :-)                                                            */
/*           Usage: rockedit filename                                         */
/*           Control-A for help.                                              */
/*           Control-W to quit the editor.                                    */
/*                                                                            */
/* Dedication:                                                                */
/*           This editor is dedicated to Chris Farmer                         */
/*           (cfarmer@itd.adelaide.edu.au), of the University of Adelaide     */
/*           Information Technology Division, whom I noticed using an         */
/*           ancient editor in a window on a modern colour workstation        */
/*           ("because it's the only editor available on that machine").      */
/*           This observation resonated with my own frustration at editors,   */
/*           and triggered by construction of Rockedit. Thanks Chris!         */
/*                                                                            */
/* Latest version:                                                            */
/*           The latest version of this program is available in the           */
/*           following FTP directory                                          */
/*           ftp://ftp.rocksoft.com/clients/rocksoft/utilities/               */
/*                                                                            */
/* Please direct comments and patches and anything else to the author:        */
/*                                                                            */
/*    Name    : Dr Ross N. Williams                                           */
/*    Company : Rocksoft Pty Ltd                                              */
/*    URL     : http://www.rocksoft.com/                                      */
/*    Email   : ross@rocksoft.com                                             */
/*    Phone   : +61 8 8232-6262                                               */
/*    Fax     : +61 8 8232-6264                                               */
/*    Snail   : PO Box 3066, Rundle Mall SA 5000, Australia.                  */
/*                                                                            */
/* Hope you find this editor useful!                                          */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* MODIFICATION LOG                                                           */
/* ----------------                                                           */
/*                                                                            */
/* Programmers:                                                               */
/*    RNW  Ross N. Williams (ross@rocksoft.com)                               */
/*                                                                            */
/* Changes:                                                                   */
/*    03-Nov-1994 RNW Released V1.0.                                          */
/*    05-Nov-1994 RNW Added c_cc[...] stuff to avoid problems under HP/UX.    */
/*    05-Nov-1994 RNW Added references section at the end.                    */
/*    06-Nov-1994 RNW Released V1.1.                                          */
/*    11-Jul-1997 RNW Updated the header comments and changed to V1.2.        */
/*    21-Jun-1998 RNW Ported to Digital Unix and changed to V1.3.             */
/*    21-Jun-1998 RNW Added ^A HELP command.                                  */
/*                                                                            */
/******************************************************************************/


/******************************************************************************/
/*                             PARAMETRIC CONSTANTS                           */
/******************************************************************************/
/* This section contains constants that are intended to be parameters of this */
/* program and can be changed to tune the editor to different situations.     */

#define TEBUFMAX 2048  /* Bytes in the terminal package output buffer.        */
#define MAXLNLEN  300  /* Maximum line length this editor can handle.         */
#define SCNROWS    24  /* Number of rows    in target terminal.               */
#define SCNCOLS    80  /* Number of columns in target terminal.               */
#define MAXFNAME  255  /* Maximum length of a filename.                       */
#define VERSION  "1.3" /* Version number of this editor.                      */
#define TEMPEXT  "tmp" /* Filename extension for temporary files.             */
#define BACKEXT  "bak" /* Filename extension for backup    files.             */


#define __386BSD__ 1


/******************************************************************************/
/*                               PLATFORM SELECTION                           */
/******************************************************************************/

/* Platforms are divided into four classes. */
#define OS_DOS 0
#define OS_VMS 0
#define OS_UNX 0
#define OS_MAC 0

/* MS-DOS. */
#ifdef MSDOS
#undef OS_DOS
#define OS_DOS 1
#endif

/* VAX/VMS and Alpha/OpenVMS. */
#ifdef VMS
#undef OS_VMS
#define OS_VMS 1
#endif

/* Unix. */
#ifdef __hpux
#undef OS_UNX
#define OS_UNX 1
#endif

#ifdef __osf__
#undef OS_UNX
#define OS_UNX 1
#endif

#ifdef sun
#undef OS_UNX
#define OS_UNX 1
#endif

#ifdef __ultrix
#undef OS_UNX
#define OS_UNX 1
#endif

#ifdef __sgi
#undef OS_UNX
#define OS_UNX 1
#endif

#ifdef __386BSD__
#undef OS_UNX
#define OS_UNX 1
#endif

#ifdef __linux__
#undef OS_UNX
#define OS_UNX 1
#endif

/* Macintosh. */
#ifdef __MWERKS__
#undef OS_MAC
#define OS_MAC 1
#endif

#ifdef THINK_C
#undef OS_MAC
#define OS_MAC 1
#endif

#if (OS_MAC + OS_UNX + OS_VMS + OS_DOS) == 0
   #error Error: No operating system class has been selected.
#endif

#define STDC 1    /* Set this symbol to 1 if you are running ANSI C.          */

/******************************************************************************/
/*                                   INCLUDES                                 */
/******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#if OS_VMS
#include <ssdef.h>
#include <descrip.h>
#include <iodef.h>
#include <ctype.h>
#include <opcdef.h>
#include unixio
#endif

#if OS_MAC
#include <console.h>
#include <stdio.h>
#endif

#if OS_DOS
#include <conio.h>
#endif

#if OS_UNX
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#endif
#include <termios.h>
#include <unistd.h>
#endif

/******************************************************************************/
/*                               GENERAL SYMBOLS                              */
/******************************************************************************/


#define ichar  int
#define bool   int
#define sign   int
#define ubyte  unsigned

#define ICHAR(X) ((int) (X))
#define CHAR(X) ((char) (X))
#define SIZE_T(X) ((size_t) (X))
#define PV (void *)

#define string char *

#define LOCAL  static
#define EXPORT
#define LOCVAR static
#define GLOVAR
#define STAVAR static
#define STKVAR static

#define NON_ZERO 1
#define DUMMY 0
#define EOS '\0'
#define EOL '\n'
#define CH_TAB 9

#if STDC

#define p_void void *
#define P_(A) A
#define ASSIGN(a,b) ((a)=(b))

#else

#define P_(A) ()
typedef int     void;
#define p_void char *
#define ASSIGN(a,b) (memcpy((char *)&(a),(char *)&(b),sizeof(a)))

#endif

#ifndef FALSE
#define FALSE (0)
#endif

#ifndef TRUE
#define TRUE (1)
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE (-1)
#endif

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS (0)
#endif

#define loop while (1)

#if OS_VMS
#undef  EXIT_SUCCESS
#undef  EXIT_FAILURE
#define EXIT_SUCCESS 1L
#define EXIT_FAILURE (0x1000002CL)
#endif

/* A little fudge never hurts, when you're in a hurry! :-) */
#define FUDGE 10

/******************************************************************************/
/*                               GLOBAL VARIABLES                             */
/******************************************************************************/
/* Because this program has been constrained to be organized as a single      */
/* program file (rather than a collection of packages as it should be), and   */
/* as C doesn't allow you to declare global variables between functions, we   */
/* wind up with a whole cluster of global variables here near the top of the  */
/* program. These variables could be eliminated by rewriting each mini        */
/* package as a multiple-instance package rather than a single-instance       */
/* package. However, in a program of this size, that would just make things   */
/* more complicated. Better to live with the globals. To ease the pain, I     */
/* have grouped the globals by package.                                       */

/*----------------------------------------------------------------------------*/
/*                        Terminology And Conventions                         */
/*----------------------------------------------------------------------------*/
/* The terms ROW  and COLUMN are used to refer to positions on screens.       */
/* The terms LINE and CHAR   are used to refer to positions within text.      */
/* Rows, columns, lines, and chars are all indexed from 1.                    */

/*----------------------------------------------------------------------------*/
/*                   Global Variables For The Terminal Package                */
/*----------------------------------------------------------------------------*/

/* Setting up immediate character input under VMS is messy. */
#if OS_VMS
 int SYS$QIOW();
 GLOVAR short ttchannel;
 GLOVAR $DESCRIPTOR(tt,"SYS$COMMAND:");
 GLOVAR struct
   {
    short status;
    short count;
    long  xstatus;
   } iosb;
 GLOVAR int vmsstatus;
#endif

/* On some systems, puts(...) calls are very much more efficient than         */
/* putchar(...) calls, especially if the putchar(...) calls are performed     */
/* synchronously. The following buffer allows us to avoid single char IO.     */
GLOVAR int  tebuflen;              /* Characters in buffer [0,TEBUFMAX].      */
GLOVAR char tebuf[TEBUFMAX+FUDGE]; /* Buffer of chars to send to stdio.       */

/*----------------------------------------------------------------------------*/
/*                   Global Variables For The Screen Package                  */
/*----------------------------------------------------------------------------*/
/* The screen package maintains a physical screen which is what it thinks is  */
/* displayed on the user's terminal, and a virtual screen which is what       */
/* should be displayed on the user's terminal.                                */
/* Edit commands update the virtual screen and the screen package figures out */
/* the differences between the two and sends the appropriate characters to    */
/* the terminal package. This simplifies code for the edit commands.          */

#define SCNSIZE (SCNROWS*SCNCOLS)
char scn_virt[SCNROWS][SCNCOLS];
char scn_phys[SCNROWS][SCNCOLS];

/*----------------------------------------------------------------------------*/
/*                    Global Variables For The Text Package                   */
/*----------------------------------------------------------------------------*/
/* The text package maintains a doubly linked ring of line records each of    */
/* which contains a forwards and backwards link and a pointer into a block in */
/* in the heap containing the line in the form of a nul-terminated C string.  */
/* The ring is anchored in a root line record that is always present, and     */
/* does not contain a line. The line buffer linbuf is used as a scratch area  */
/* when a line is being edited. It is blank-padded, not nul-terminated.       */

typedef struct line_t_ line_t;
#define p_line_t line_t *
struct line_t_
  {
   p_line_t p_prev;  /* Pointer to the previous line record.                  */
   p_line_t p_next;  /* Pointer to the next     line record.                  */
   string   p_data;  /* Pointer to the line itself (C string in heap).        */
  };

GLOVAR line_t   root;      /* The root line (unused as a line).               */
GLOVAR p_line_t p_root;    /* Pointer to the root line.                       */
GLOVAR int      numlines;  /* Number of lines in the text.                    */
GLOVAR char     linbuf[MAXLNLEN+FUDGE];  /* Handy line buffer.                */

/*----------------------------------------------------------------------------*/
/*                           General Global Variables                         */
/*----------------------------------------------------------------------------*/
/* This section contains general global variables that are needed at a high   */
/* level to perform the actual editing.                                       */

GLOVAR p_line_t  p_curr; /* Ptr to the current line (or root if at EOF).      */
GLOVAR int cur_line;     /* Line   in the text   of the cursor [1,infinity].  */
GLOVAR int cur_char;     /* Char   in the text   of the cursor [1,MAXLNLEN].  */
GLOVAR int cur_row;      /* Row    on the screen of the cursor [1,SCNROWS].   */
GLOVAR int cur_col;      /* Column on the screen of the cursor [1,SCNCOLS].   */

/******************************************************************************/
/*                     DECLARATIONS FOR SOME FUNCTIONS                        */
/******************************************************************************/

LOCAL void paintall P_((void));
LOCAL void paintrow P_((void));


/******************************************************************************/
/*                           MISCELLANEOUS FUNCTIONS                          */
/******************************************************************************/
/* This section contains miscellaneous functions that don't really belong     */
/* anywhere else.                                                             */

LOCAL void bomb P_((string));
LOCAL void bomb (s)
/* Writes out its argument string and then bombs the program. */
string s;
{
 printf("\n");
 printf("Rockedit assertion failure:\n");
 printf("   %s\n",s);

 /* Wait for a RETURN. */
 loop
   {
    int ich1;
    int ich2;

    fprintf(stderr,"Press RETURN to abort Veracity>\n");

    /* Grab the next character and gobble the rest of the line. */
    ich1=ich2=getchar();
    while ((ich2 != EOL) && (ich2 != EOF)) ich2=getchar();

    if ((ich1 == EOL) || (ich1 == EOF)) break;
    if (ich1 == '#') return;

    /* Not recognised, so try again. */
   }
 {* ((char *) 0) = 0; } /* Bomb so we can get a stackdump. */

 exit(EXIT_FAILURE);
}

/*----------------------------------------------------------------------------*/

LOCAL void as P_((bool,string));
LOCAL void as (b,s)
/* Bombs with an assertion failure if its first argument is FALSE. */
bool   b;
string s;
{
 if (!b) bomb(s);
}

/*----------------------------------------------------------------------------*/

LOCAL p_void mymalloc P_((size_t));
LOCAL p_void mymalloc (n)
/* The same as malloc except it bombs if it cannot perform the allocation. */
size_t n;
{
 p_void p;
 size_t bytes = n;

 /* Digital Unix's malloc fails if asked for a zero-length block! */
 if (bytes == 0) bytes = 1;

 if (n > SIZE_T(1000000L))
   printf("mymalloc: Warning: Was asked for %lu bytes!\n",
          (unsigned long) n);

 p = malloc(bytes);

 as(p != NULL,"mymalloc: Rockedit ran out of memory.");
 return p;
}

/*----------------------------------------------------------------------------*/

LOCAL bool blankrow P_((string));
LOCAL bool blankrow (p)
/* Returns TRUE iff p[0..SCNCOLS-1] are all blanks. */
string p;
{
 int i;
 for (i=0; i<SCNCOLS; i++)
    if (p[i] != ' ')
       return FALSE;
 return TRUE;
}

/*----------------------------------------------------------------------------*/

LOCAL void zap_trail P_((string));
LOCAL void zap_trail (s)
/* Deletes trailing blanks from its argument string. */
string s;
{
 string p = s;
 while (*s != EOS)
   {
    if (*s != ' ')
       p=s+1;
    s++;
   }
 *p=EOS;
}

/*----------------------------------------------------------------------------*/

LOCAL bool fexists P_((string));
LOCAL bool fexists (filename)
/* Returns TRUE iff the argument file exists. */
string filename;
{
 FILE *file;
 bool success;

 file=fopen(filename,"r");
 if (file==NULL) return FALSE;

 success= (bool) (fclose(file) == 0);
 as(success,"fexists: Error closing file whose existence is being tested!");

 return TRUE;
}

/*----------------------------------------------------------------------------*/

LOCAL void setext P_((string,string));
LOCAL void setext (s,e)
/* If s contains one or more ".", replaces everything to the right of */
/* the leftmost "." by e. Note: setext = set extension.               */
/* If s doesn't contain a ".", appends a "." followed by e.           */
/* Make sure there's enough room in the string!                       */
string s;
string e;
{
 while ((*s != EOS) && (*s != '.')) s++;
 *s++='.';
 strcpy(s,e);
}

/*----------------------------------------------------------------------------*/

LOCAL void purify P_((string));
LOCAL void purify (st)
/* Deletes all non-printables from the argument string. */
/* Replaces each TAB by a space.                        */
string st;
{
 string s = st;
 string d = st;

 while (*s)
   {
    if ((' '<= *s) && (*s<='~')) *d++ = *s;
    if (*s==CH_TAB) *d++=' ';
    s++;
   }
 *d=EOS;
}

/******************************************************************************/
/*                               TERMINAL PACKAGE                             */
/******************************************************************************/
/* The terminal package provides a very low level abstract interface to the   */
/* terminal. The package maintains an output buffer and has to be initialized */
/* and finalized. The buffer must be flushed on occassions too.               */

/*----------------------------------------------------------------------------*/

LOCAL void te_flu P_((void));
LOCAL void te_flu ()
/* Flushes the terminal's output buffer tebuf to stdout. */
{
 if (tebuflen == 0) return;

#if OS_VMS
 vmsstatus = SYS$QIOW(0,ttchannel,IO$_WRITEVBLK,
                      &iosb,0,0,&tebuf,tebuflen,0,0,0,0);
 if ((vmsstatus != SS$_NORMAL) && (iosb.status != SS$_NORMAL))
    bomb("Fatal error trying to flush output buffer.");
#else
 tebuf[tebuflen]=EOS;
 printf("%s",tebuf);
#endif
 tebuflen = 0;
}
/*----------------------------------------------------------------------------*/

LOCAL ichar te_gch P_((void));
LOCAL ichar te_gch ()
/* Get a character from the console. */
{
 ichar ch;

 /* Flush the output buffer so the user isn't expected to enter input */
 /* before the prompt is written out!                                 */
 te_flu();

#if OS_DOS
  ch = getch();
#endif

#if OS_VMS
 vmsstatus = SYS$QIOW(0,ttchannel,IO$_READVBLK|IO$M_NOECHO|IO$M_NOFILTR,
                      &iosb,0,0,&ch,1,0,0,0,0))
 if ((vmsstatus != SS$_NORMAL) && (iosb.status != SS$_NORMAL))
    bomb("Fatal error trying to read a character from the console.");
#endif

#if OS_UNX
  ch = getchar();
#endif

#if OS_MAC
 {
  int c;
  do {c=getchar();} while (c == EOF);
  ch = c;
 }
#endif

 return ch;
}

/*----------------------------------------------------------------------------*/

LOCAL void te_chr P_((ichar));
LOCAL void te_chr (ch)
/* Writes its argument character to the terminal. */
ichar ch;
{
 tebuf[tebuflen++]=(char) ch;
 if (tebuflen==TEBUFMAX) te_flu();
}

/*----------------------------------------------------------------------------*/

LOCAL void te_str P_((string));
LOCAL void te_str (s)
/* Writes its argument string to the terminal. */
string s;
{
 while (*s) te_chr(ICHAR(*s++));
}

/*----------------------------------------------------------------------------*/

LOCAL void te_mov P_((int,int));
LOCAL void te_mov (r,c)
/* Moves the cursor to the specified row and column on the screen. */
int r; /* Row [1,SCNROWS]. 1 => Top row.     */
int c; /* Col [1,SCNCOLS]. 1 => Left column. */
{
 as((1<=r) && (r<=SCNROWS),"te_mov: Bad row.");
 as((1<=c) && (c<=SCNCOLS),"te_mov: Bad col.");

#if OS_DOS
 te_flu();
 gotoxy(c,r);
#else
#if OS_MAC
 te_flu();
 cgotoxy(c,r,stdout);
#else
 {
  char x[10+FUDGE];
  sprintf(x,"\033[%d;%dH",r,c); /* ANSI cursor position code. */
  te_str(x);
 }
#endif
#endif
}

/*----------------------------------------------------------------------------*/

LOCAL void te_cln P_((int));
LOCAL void te_cln (row)
/* Sets the specified row of the terminal to blanks.   */
/* Leaves the cursor at the start of the cleared line. */
int row;
{
 te_mov(row,1);

#if OS_MAC
   ccleol(stdout);
#else
  te_str("\033[2K"); /* ANSI clear line sequence. */
#endif
}

/*----------------------------------------------------------------------------*/

LOCAL void te_clr P_((void));
LOCAL void te_clr ()
/* Homes the cursor and clears the screen. */
{
 int r;
 for (r=1; r<=SCNROWS; r++)
    te_cln(r);
 te_mov(1,1);
}

/*----------------------------------------------------------------------------*/

LOCAL void te_bel P_((void));
LOCAL void te_bel ()
/* Rings the terminal's bell. */
{
 te_chr(7);
}

/*----------------------------------------------------------------------------*/

LOCAL void te_ini P_((void));
LOCAL void te_ini ()
/* Initializes the terminal package. */
{
 /* Clear the terminal package's buffer. */
 tebuflen = 0;

#if OS_VMS
 vmsstatus = SYS$ASSIGN(&tt,&ttchannel,0,0);
 as(vmsstatus == SS$_NORMAL,"Can't get channel to SYS$COMMAND.");
#endif

#if OS_MAC
 csetmode((int) C_RAW,stdout);
#endif
}

/*----------------------------------------------------------------------------*/

LOCAL void te_fin P_((void));
LOCAL void te_fin ()
/* Finalize the terminal package. */
{
 te_flu();
}

/******************************************************************************/
/*                                SCREEN PACKAGE                              */
/******************************************************************************/
/* The screen package maintains a physical screen which is what it thinks is  */
/* displayed on the user's terminal, and a virtual screen which is what       */
/* should be displayed on the user's terminal. It then provides:              */
/*    1. A collection of functions for manipulating the virtual screen.       */
/*    2. A function sc_upd(...) to update the physical screen from the        */
/*       virtual screen.                                                      */
/* The intent is that the editor commands manipulate the screen through this  */
/* screen package using high level screen package calls that do not require   */
/* any knowledge of the underlying terminal mechanisms.                       */

/*----------------------------------------------------------------------------*/

LOCAL void sc_clr P_((void));
LOCAL void sc_clr ()
/* Clear the screen. */
{
 memset(&scn_virt[0][0],' ',SIZE_T(SCNSIZE));
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_crw P_((int));
LOCAL void sc_crw (row)
/* Clear the specified row of the screen. */
int row;
{
 as((1<=row) && (row<=SCNROWS),"sc_crw: Bad row number.");
 memset(&scn_virt[row-1][0],' ',SIZE_T(SCNCOLS));
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_chr P_((int,int,ichar));
LOCAL void sc_chr (row,col,ch)
/* Places the specified character at the specified row and column on the      */
/* screen. If the row and column are off screen, it simply does nothing.      */
int   row;
int   col;
ichar  ch;
{
 if (((1 <= row) && (row <= SCNROWS)) &&
     ((1 <= col) && (col <= SCNCOLS)))
   scn_virt[row-1][col-1] = (char) ch;
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_str P_((int,int,string));
LOCAL void sc_str (row,col,s)
/* Writes the specified string on the screen at the specified row and column. */
/* The function ignores any part of the string that falls off the screen.     */
int    row;
int    col;
string s;
{
 int    c = col;
 string t = s;
 while (*t) sc_chr(row,c++,ICHAR(*t++));
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_upd P_((void));
LOCAL void sc_upd ()
/* Updates the physical screen from the virtual screen by:                    */
/* - Identifying the differences between the physical and virtual screens.    */
/* - Sending characters to the terminal package to implement the changes.     */
/* - Setting the physical screen to the virtual screen.                       */
{
 int r; /* Current row.    */
 int c; /* Current column. */

 for (r=1; r<=SCNROWS; r++)
   {
    /* If the two rows are identical, we can skip this row. */
    if (memcmp(&scn_virt[r-1][0],
               &scn_phys[r-1][0],SIZE_T(SCNCOLS)) == 0)
       continue;

    /* If the virtual row is blank, we can take a shortcut. */
    if ( ( blankrow(&scn_virt[r-1][0])) &&
         (!blankrow(&scn_phys[r-1][0])) )
       te_cln(r);
    else
      {
       bool there = FALSE;  /* TRUE iff ready to write next char. */
       for (c=1; c<=SCNCOLS; c++)
          {
           char ch = scn_virt[r-1][c-1];
           if (ch != scn_phys[r-1][c-1])
             {
              if (!there) te_mov(r,c);
              te_chr(ICHAR(ch));
              there=TRUE;
             }
           else
              there=FALSE;
          }
      }

    /* Update the physical row from the virtual row. */
    memmove(&scn_phys[r-1][0],&scn_virt[r-1][0],SIZE_T(SCNCOLS));
   }

 te_flu();    /* Flush all we've done to the terminal itself.              */
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_fup P_((void));
LOCAL void sc_fup ()
/* Forced update. Forces the terminals screen to be redrawn from scratch from */
/* the virtual screen.                                                        */
{
 /* Fill physical screen with crud. */
 memset(&scn_phys[0][0],255,SIZE_T(SCNSIZE));

/* Perform an ordinary update. */
 sc_upd();
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_ini P_((void));
LOCAL void sc_ini ()
/* Initializes the screen package, clearing the screen. */
{
 sc_clr();
 sc_fup();
}

/*----------------------------------------------------------------------------*/

LOCAL void sc_fin P_((void));
LOCAL void sc_fin ()
/* Finalizes the screen package, clearing the screen. */
{
 sc_clr();
 sc_fup();
}

/******************************************************************************/
/*                                 TEXT PACKAGE                               */
/******************************************************************************/
/* The text package provides functions to manipulate the global doubly linked */
/* line ring rooted in the line record 'root'.

/*----------------------------------------------------------------------------*/

LOCAL void tx_ini P_((void));
/* Initialize the text data structure to the empty list. */
LOCAL void tx_ini ()
{
 p_root         = &root;
 p_root->p_next = p_root;
 p_root->p_prev = p_root;
 p_root->p_data = NULL;
 numlines       = 0;
}

/*----------------------------------------------------------------------------*/

LOCAL void tx_fin P_((void));
LOCAL void tx_fin ()
/* Finalize the text data structure. */
{
}

/*----------------------------------------------------------------------------*/

LOCAL void tx_set P_((p_line_t,string));
LOCAL void tx_set (p_line,s)
/* Sets the specified line to the specified string value. */
/* Deletes trailing spaces from the argument string first. */
p_line_t p_line;
string   s;
{
 size_t len;
 zap_trail(s);
 len = strlen(s);
 as(len < MAXLNLEN,"tx_set: Line too long.");
 as(p_line != p_root      ,"tx_set: Attempt to set the root line.");
 as(p_line->p_data != NULL,"tx_set: p_data=NULL.");
 free(p_line->p_data);
 p_line->p_data = mymalloc(SIZE_T(len+1));
 strcpy(p_line->p_data,s);
}

/*----------------------------------------------------------------------------*/

LOCAL void tx_ins P_((p_line_t,string));
LOCAL void tx_ins (p_line,s)
/* Insert a line containing the specified string */
/* just before the specified line.               */
p_line_t p_line;
string   s;
{
 p_line_t p_new        = mymalloc(SIZE_T(sizeof(line_t)));
 p_new->p_prev         = p_line->p_prev;
 p_new->p_next         = p_line;
 p_line->p_prev        = p_new;
 p_new->p_prev->p_next = p_new;
 p_new->p_data         = mymalloc(SIZE_T(0));
 tx_set(p_new,s);
 numlines++;
}

/*----------------------------------------------------------------------------*/

LOCAL void tx_del P_((p_line_t));
LOCAL void tx_del (p_line)
/* Deletes the specified line. */
p_line_t p_line;
{
 as(p_line != NULL,"tx_del: NULL.");
 as(p_line != p_root,"tx_del: Attempt to delete the root line.");
 p_line->p_prev->p_next = p_line->p_next;
 p_line->p_next->p_prev = p_line->p_prev;
 free(p_line->p_data);
 free(p_line);
 numlines--;
}


/*----------------------------------------------------------------------------*/

LOCAL void tx_get P_((p_line_t));
LOCAL void tx_get (p_line)
/* Writes the contents of the line to the global line buffer as a blank       */
/* padded array of MAXLNLEN characters.                                       */
p_line_t p_line;
{
 size_t len = strlen(p_line->p_data);
 memset(PV linbuf,ICHAR(' '),SIZE_T(MAXLNLEN));
 memmove(PV linbuf,p_line->p_data,len);
}

/*----------------------------------------------------------------------------*/

LOCAL void tx_put P_((p_line_t));
LOCAL void tx_put (p_line)
/* Sets the value of the specified line to the value of the global linebuffer.*/
p_line_t p_line;
{
 linbuf[MAXLNLEN]=EOS;
 tx_set(p_line,linbuf);
}

/******************************************************************************/
/*                          FILE INPUT/OUTPUT PACKAGE                         */
/******************************************************************************/
/* This package provides the functions that perform all the actual reading    */
/* and writing of the files the editor is manipulating.                       */

LOCAL void filein P_((string));
LOCAL void filein (filename)
/* Reads the specified file into the text data structure. */
string filename;
{
 FILE *file = fopen(filename,"r");
 if (file == NULL) bomb("Can't open input file.");
 while (TRUE)
   {
    size_t len;
    linbuf[0]=EOS;
    if (fgets(linbuf,MAXLNLEN+1,file) == NULL) break;
    len = strlen(linbuf);
    if ((len < 1) || (linbuf[len-1] != EOL)) bomb("Line is too long.");
    linbuf[len-1]=EOS;
    purify(linbuf);
    tx_ins(p_root,linbuf);
   }
 if (ferror(file))      bomb("Error reading input file.");
 if (fclose(file) != 0) bomb("Can't close input file.");
}

/*----------------------------------------------------------------------------*/

LOCAL void fileout P_((string));
LOCAL void fileout (filename)
/* Writes the text data structure to the specified file. */
/* Uses the usual temporary file mechanism.              */
string filename;
{
 FILE *file;
 char tempname[MAXFNAME+10];
 char backname[MAXFNAME+10];
 p_line_t p_line = p_root->p_next;

 /* Compute temporary filename and backup filename. */
 strcpy(tempname,filename);
 setext(tempname,TEMPEXT);
 strcpy(backname,filename);
 setext(backname,BACKEXT);

 /* Create the temporary output file. */
 file = fopen(tempname,"w");
 if (file == NULL)
   {
    printf("\n");
    printf("Error creating temporary file \"%s\".\n",tempname);
    exit(EXIT_FAILURE);
   }

 /* Write the text to the temporary output file. */
 while (p_line != p_root)
   {
    if (fputs(p_line->p_data,file) == EOF)
       bomb("Error writing output file.");
    fputc(EOL,file);
    p_line = p_line->p_next;
   }

 /* Close the temporary file. */
 if (ferror(file))      bomb("Error writing temporary file.");
 if (fclose(file) != 0) bomb("Can't closing temporary file.");

 /* Delete the old backup file. */
 remove(backname); /* If we can't delete it, too bad. */

 /* Rename the target file to the backup file. */
 if (rename(filename,backname) != 0)
   {
    printf("Error renaming \"%s\" to \"%s\".\n",filename,backname);
    exit(EXIT_FAILURE);
   }

 /* Rename the temporary file to the target file. */
 if (rename(tempname,filename) != 0)
   {
    printf("Error renaming \"%s\" to \"%s\".\n",tempname,filename);
    exit(EXIT_FAILURE);
   }
}

/******************************************************************************/
/*                               EDITING COMMANDS                             */
/******************************************************************************/
/* This section contains a group of functions each of which implements a      */
/* single editing command.                                                    */

LOCAL void do_red P_((void));
LOCAL void do_red ()
/* Redraw the screen. */
{
 sc_fup();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_cup P_((void));
LOCAL void do_cup ()
/* Cursor up. */
{
 if (cur_line == 1) {te_bel(); return;}
 cur_line--;
 p_curr = p_curr->p_prev;
 if (cur_row == 1)
    paintall();
 else
    cur_row--;
}

/*----------------------------------------------------------------------------*/

LOCAL void do_cdw P_((void));
LOCAL void do_cdw ()
/* Cursor down. */
{
 if (p_curr->p_next == p_root) {te_bel(); return;}
 p_curr = p_curr->p_next;
 cur_line++;
 if (cur_row == SCNROWS)
    paintall();
 else
   cur_row++;
}

/*----------------------------------------------------------------------------*/

LOCAL void do_clf P_((void));
LOCAL void do_clf ()
/* Cursor left. */
{
 if (cur_char == 1) {te_bel(); return;}
 cur_char--;
 if (cur_col == 1)
    paintall();
 else
    cur_col--;
}

/*----------------------------------------------------------------------------*/

LOCAL void do_crt P_((void));
LOCAL void do_crt ()
/* Cursor right. */
{
 if (cur_char == MAXLNLEN) {te_bel(); return;}
 cur_char++;
 if (cur_col == SCNCOLS)
    paintall();
 else
    cur_col++;
}

/*----------------------------------------------------------------------------*/

LOCAL void do_pdw P_((void));
LOCAL void do_pdw ()
/* Page down. */
{
 int i;

 if (cur_line == numlines+1) {te_bel(); return;}

 for (i=0; i<SCNROWS; i++)
   {
    if (cur_line == numlines+1) break;
    p_curr = p_curr->p_next;
    cur_line++;
   }
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_pup P_((void));
LOCAL void do_pup ()
/* Page up. */
{
 int i;

 if (cur_line == 1) {te_bel(); return;}

 for (i=0; i<SCNROWS; i++)
   {
    if (cur_line == 1) break;
    p_curr = p_curr->p_prev;
    cur_line--;
   }
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_ldw P_((void));
LOCAL void do_ldw ()
/* Long distance down. */
{
 int i;

 if (cur_line == numlines+1) {te_bel(); return;}

 for (i=0; i<100; i++)
   {
    if (cur_line == numlines+1) break;
    p_curr = p_curr->p_next;
    cur_line++;
   }
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_lup P_((void));
LOCAL void do_lup ()
/* Long distance up. */
{
 int i;

 if (cur_line == 1) {te_bel(); return;}

 for (i=0; i<100; i++)
   {
    if (cur_line == 1) break;
    p_curr = p_curr->p_prev;
    cur_line--;
   }
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_ret P_((void));
LOCAL void do_ret ()
/* Return. */
{
 cur_char = 1;
 cur_col  = 1;
 do_cdw();
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_tab P_((void));
LOCAL void do_tab ()
/* Tab. */
{
 int x = cur_char;
 do
   {
    do_crt();
    x++;
   }
 while (((x-1) % 8) != 0);
}

/*----------------------------------------------------------------------------*/

LOCAL void do_top P_((void));
LOCAL void do_top ()
/* Jump to top of document. */
{
 p_curr   = p_root->p_next;
 cur_line = 1;
 cur_char = 1;
 cur_row  = 1;
 cur_col  = 1;
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_bot P_((void));
LOCAL void do_bot ()
/* Jump to bottom of document. */
{
 p_curr   = p_root;
 cur_line = numlines+1;
 cur_row  = numlines+1;
 cur_char = 1;
 cur_col  = 1;
 if (cur_row > SCNROWS) cur_row=SCNROWS;
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_chr P_((ichar));
LOCAL void do_chr (ch)
/* Type the specified character. */
ichar ch;
{
 int i;
 if (p_curr == p_root) {te_bel(); return;}

 /* Insert the character in the current line. */
 tx_get(p_curr);
  for (i=MAXLNLEN-1; i>cur_char-1; i--)
     linbuf[i]=linbuf[i-1];
 linbuf[cur_char-1] = CHAR(ch);
 tx_put(p_curr);

 do_crt();
 paintrow();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_dch P_((void));
LOCAL void do_dch ()
/* Delete character. */
{
 int i;
 if (p_curr == p_root) {te_bel(); return;}

 /* Delete the current character, shifting to the left. */
 tx_get(p_curr);
  for (i=cur_char-1; i<MAXLNLEN-1; i++)
     linbuf[i]=linbuf[i+1];
 linbuf[MAXLNLEN-1]=' ';
 tx_put(p_curr);
 paintrow();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_iln P_((void));
LOCAL void do_iln ()
/* Insert line. */
{
 tx_ins(p_curr,"");
 p_curr=p_curr->p_prev;
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_dln P_((void));
LOCAL void do_dln ()
/* Delete line. */
{
 p_line_t save = p_curr->p_next;

 if (p_curr == p_root) {te_bel(); return;}
 tx_del(p_curr);
 p_curr=save;
 paintall();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_del P_((void));
LOCAL void do_del ()
/* Delete. */
{
 if (cur_char == 1) {te_bel(); return;}
 do_clf();
 do_dch();
}

/*----------------------------------------------------------------------------*/

LOCAL void do_hel P_((void));
LOCAL void do_hel ()
/* Help. */
{
 /* Clear the screen and write out a help message. */
 te_clr(); te_flu();
 printf("ROCKEDIT COMMANDS\n");
 printf("=================\n");
 printf("Use the arrow keys to move around. Type to insert.\n");
 printf("\n");
 printf("^A Help.\n");
 printf("^B Page up.\n");
 printf("^D Delete character.\n");
 printf("^E End of file.\n");
 printf("^F Page down.\n");
 printf("^I Jump right.\n");
 printf("^K Delete line.\n");
 printf("^L Insert line.\n");
 printf("^M Return.\n");
 printf("^N Redraw screen.\n");
 printf("^R Right.\n");
 printf("^T Top of file.\n");
 printf("^U Up 100 lines.\n");
 printf("^V Down 100 lines.\n");
 printf("^W Quit.\n");
 printf("\n");
 printf("Press any key to return to editing>");
 te_gch();

 /* Restore screen to whatever it was before the user asked for help. */
 sc_fup();
}

/******************************************************************************/
/*                          MAIN CONTROL FUNCTIONS                            */
/******************************************************************************/

LOCAL void paintrow ()
/* Redraws the current row of the virtual screen */
/* from scratch from the current settings.       */
{
 int left_pos = cur_char - (cur_col-1);

 sc_crw(cur_row);
 if (p_curr == p_root)
    sc_str(cur_row,1,"<eof>");
 else
    if (strlen(p_curr->p_data) >= SIZE_T(left_pos))
       sc_str(cur_row,1,p_curr->p_data+(left_pos-1));
}

/*----------------------------------------------------------------------------*/

LOCAL void paintall ()
/* Redraws the virtual screen from scratch from the current settings. */
{
 int      r;
 p_line_t p    = p_curr;
 int left_pos = cur_char - (cur_col-1);

 for (r=1; r<cur_row; r++)
    p = p->p_prev;

 sc_clr();
 for (r=1; r<=SCNROWS; r++)
   {
    if (p == p_root)
      {
       sc_str(r,1,"<eof>");
       break;
      }
    if (strlen(p->p_data) >= SIZE_T(left_pos))
       sc_str(r,1,p->p_data+(left_pos-1));
    p = p->p_next;
   }
}

/*----------------------------------------------------------------------------*/

LOCAL void edit P_((void));
LOCAL void edit ()
{
 cur_row  = 1;
 cur_col  = 1;
 cur_line = 1;
 cur_char = 1;
 p_curr   = p_root->p_next;

 paintall();
 sc_fup();

 while (TRUE)
   {
    char ch;
    sc_upd();
    te_mov(cur_row,cur_col);
    ch = CHAR(te_gch());
    if ((ch < 0) || (ch > 127))
       te_bel();
    else
      if ((' ' <= ch) && (ch <= '~'))
         do_chr(ICHAR(ch));
      else
         switch (ch)
           {
            case   0: te_bel(); break; /* NUL                          */
            case   1: do_hel(); break; /* Control-A. Help.             */
            case   2: do_pup(); break; /* Control-B. Page up.          */
            case   3: te_bel(); break; /* Control-C. UNUSABLE.         */
            case   4: do_dch(); break; /* Control-D. Delete character. */
            case   5: do_bot(); break; /* Control-E. End of text.      */
            case   6: do_pdw(); break; /* Control-F. Page down.        */
            case   7: te_bel(); break; /* Control-G.                   */
            case   8: do_del(); break; /* Control-H. Delete/rubout.    */
            case   9: do_tab(); break; /* Control-I. Tab.              */
            case  10: do_ret(); break; /* Control-J.                   */
            case  11: do_dln(); break; /* Control-K. Delete line.      */
            case  12: do_iln(); break; /* Control-L. Insert line.      */
            case  13: do_ret(); break; /* Control-M. Return.           */
            case  14: do_red(); break; /* Control-N. Redraw screen.    */
            case  15: te_bel(); break; /* Control-O.                   */
            case  16: te_bel(); break; /* Control-P.                   */
            case  17: te_bel(); break; /* Control-Q. UNUSABLE.         */
            case  18: do_crt(); break; /* Control-R. Cursor right.     */
            case  19: te_bel(); break; /* Control-S. UNUSABLE.         */
            case  20: do_top(); break; /* Control-T. Top of file.      */
            case  21: do_lup(); break; /* Control-U. Long dist up.     */
            case  22: do_ldw(); break; /* Control-V. Long dist down.   */
            case  23: goto quit;       /* Control-W. Quit.             */
            case  24: te_bel(); break; /* Control-X. UNUSABLE.         */
            case  25: te_bel(); break; /* Control-Y. UNUSABLE.         */
            case  26: te_bel(); break; /* Control-Z. UNUSABLE.         */
            /* See later for escape. */
            case  28: do_clf(); break; /* ?????????. Cursor left.      */
            case  29: do_crt(); break; /* ?????????. Cursor right.     */
            case  30: do_cup(); break; /* ?????????. Cursor up.        */
            case  31: do_cdw(); break; /* ?????????. Cursor down.      */
            /* 32..126 => Printables. */
            case 127: do_del(); break;
            case  27: /* ESCAPE */
              ch = CHAR(te_gch());
              if (ch != 91)
                 te_bel();
              else
               {
                ch = CHAR(te_gch());
                switch (ch)
                  {
                   case 65: do_cup(); break;
                   case 66: do_cdw(); break;
                   case 67: do_crt(); break;
                   case 68: do_clf(); break;
                   default: te_bel(); break;
                  }
               }
              break;
            default : bomb("Character switch defaulted.");
           }
   } /* While */

 quit:;
}

/*----------------------------------------------------------------------------*/

int main(argc,argv)
int    argc;
char **argv;
{
#if OS_MAC
 argc = ccommand(&argv);
#endif

#if OS_UNX
 {
  struct termios attr;
  int status;
  status = tcgetattr(STDIN_FILENO,&attr);
  as(status==0,"Can't get terminal attributes.");
  attr.c_lflag &= ~(ICANON);
  attr.c_lflag &= ~(ECHO);
  attr.c_cc [VMIN]  = 1; /* [Lewine91] p.156. */
  attr.c_cc [VTIME] = 0;
  status = tcsetattr(STDIN_FILENO,TCSANOW,&attr);
  as(status==0,"Can't put terminal attributes.");
 }
#endif

 /* Ensure that there is exactly one argument. */
 if (argc != 2)
   {
    printf("Welcome to ROCKEDIT %s: Rocksoft's Portable Editor.\n",VERSION);
    printf("\n");
    printf("Usage: rockedit filename\n");
    printf("\n");
    printf("Once running, use Control-A for help and Control-W to quit.\n");
    exit(EXIT_FAILURE);
   }

 /* Ensure that filename is not too long. */
 if (strlen(argv[1]) > MAXFNAME)
   {
    printf("Argument filename is too long.");
    exit(EXIT_FAILURE);
   }

 /* If the file does not exist, create it. */
 if ((strcmp(argv[1],"echochar") != 0) &&
     (fexists(argv[1])!=TRUE))
   {
    FILE *file = fopen(argv[1],"w");
    if (file == NULL)
      {
       printf("\n");
       printf("Error creating file \"%s\".\n",argv[1]);
       exit(EXIT_FAILURE);
      }
    printf("Created new file \"%s\".\n",argv[1]);
   }

 te_ini(); /* Initialize the terminal package. */
 sc_ini(); /* Initialize the screen   package. */
 tx_ini(); /* Initialize the text     package. */

 /* Special echo input test mode. */
 if (strcmp(argv[1],"echochar")==0)
   {
    int i;
    printf("Echo test mode (exits after 30 chars).\n");
    for (i=0; i<30; i++)
      {
       unsigned j = (unsigned) te_gch();
       printf("%u\n",j);
      }
    printf("Completed test.\n");
    exit(EXIT_FAILURE);
   }

 filein(argv[1]);
 edit();
 fileout(argv[1]);

 tx_fin(); /* Finalize the text     package. */
 sc_fin(); /* Finalize the screen   package. */
 te_fin(); /* Finalize the terminal package. */

 printf("You just edited \"%s\".\n",argv[1]);

#if OS_UNX
 {
  struct termios attr;
  tcgetattr(STDIN_FILENO,&attr);
  attr.c_lflag |= ICANON;
  attr.c_lflag |= ECHO;
  tcsetattr(STDIN_FILENO,TCSAFLUSH,&attr);
 }
#endif

 exit(EXIT_SUCCESS);
 return 0; /* Keep lint happy. */
}

/******************************************************************************/
/*                                                                            */
/* REFERENCES                                                                 */
/* ----------                                                                 */
/* As this program is supposed to be extremely portable, it's important that  */
/* modifications made to enhance its portability are well-founded. For this   */
/* reason, I'm including this references section at the end. The purpose is   */
/* allow various texts on C portability to be referenced conveniently         */
/* throughout the program.                                                    */
/*                                                                            */
/* [ANSIC] "Programming Languages - C", ISO/IEC 9899:1990.                    */
/*                                                                            */
/* [Lewine91] "Posix Programmer's Guide", O'Reilly and Associates,            */
/* (ISBN: 0-937175-73-0), 1991.                                               */
/*                                                                            */
/******************************************************************************/
/*                                End of ROCKEDIT                             */
/******************************************************************************/
